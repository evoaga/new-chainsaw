// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: exercise_logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getExerciseLogByDetails = `-- name: GetExerciseLogByDetails :one
SELECT id
FROM exercise_logs
WHERE user_id = $1
  AND exercise_id = $2
  AND reps = $3
  AND weight = $4
  AND log_date = $5
`

type GetExerciseLogByDetailsParams struct {
	UserID     int32              `json:"user_id"`
	ExerciseID int32              `json:"exercise_id"`
	Reps       int32              `json:"reps"`
	Weight     pgtype.Numeric     `json:"weight"`
	LogDate    pgtype.Timestamptz `json:"log_date"`
}

func (q *Queries) GetExerciseLogByDetails(ctx context.Context, arg GetExerciseLogByDetailsParams) (int32, error) {
	row := q.db.QueryRow(ctx, getExerciseLogByDetails,
		arg.UserID,
		arg.ExerciseID,
		arg.Reps,
		arg.Weight,
		arg.LogDate,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getExerciseLogs = `-- name: GetExerciseLogs :many
SELECT el.id, el.exercise_id, e.name AS exercise_name, el.reps, el.weight, el.log_date
FROM exercise_logs el
JOIN exercises e ON el.exercise_id = e.id
WHERE el.user_id = $1
ORDER BY el.log_date DESC
`

type GetExerciseLogsRow struct {
	ID           int32              `json:"id"`
	ExerciseID   int32              `json:"exercise_id"`
	ExerciseName string             `json:"exercise_name"`
	Reps         int32              `json:"reps"`
	Weight       pgtype.Numeric     `json:"weight"`
	LogDate      pgtype.Timestamptz `json:"log_date"`
}

func (q *Queries) GetExerciseLogs(ctx context.Context, userID int32) ([]GetExerciseLogsRow, error) {
	rows, err := q.db.Query(ctx, getExerciseLogs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseLogsRow
	for rows.Next() {
		var i GetExerciseLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExerciseID,
			&i.ExerciseName,
			&i.Reps,
			&i.Weight,
			&i.LogDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesWithLatestLogDate = `-- name: GetExercisesWithLatestLogDate :many
WITH latest_logs AS (
    SELECT
        exercise_id,
        MAX(log_date) AS latest_log_date
    FROM
        exercise_logs
    WHERE
        user_id = $1
    GROUP BY
        exercise_id
)
SELECT
    e.id,
    e.name,
    el.log_date,
    el.reps,
    el.weight,
    el.bodyweight_id
FROM
    exercises e
JOIN
    exercise_logs el
ON
    e.id = el.exercise_id
JOIN
    latest_logs ll
ON
    el.exercise_id = ll.exercise_id AND el.log_date = ll.latest_log_date
WHERE
    el.user_id = $1
`

type GetExercisesWithLatestLogDateRow struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	LogDate      pgtype.Timestamptz `json:"log_date"`
	Reps         int32              `json:"reps"`
	Weight       pgtype.Numeric     `json:"weight"`
	BodyweightID int32              `json:"bodyweight_id"`
}

func (q *Queries) GetExercisesWithLatestLogDate(ctx context.Context, userID int32) ([]GetExercisesWithLatestLogDateRow, error) {
	rows, err := q.db.Query(ctx, getExercisesWithLatestLogDate, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExercisesWithLatestLogDateRow
	for rows.Next() {
		var i GetExercisesWithLatestLogDateRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LogDate,
			&i.Reps,
			&i.Weight,
			&i.BodyweightID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logExercise = `-- name: LogExercise :exec

INSERT INTO exercise_logs (user_id, exercise_id, reps, weight, additional_weight, exercise_type, bodyweight_id, log_date)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type LogExerciseParams struct {
	UserID           int32              `json:"user_id"`
	ExerciseID       int32              `json:"exercise_id"`
	Reps             int32              `json:"reps"`
	Weight           pgtype.Numeric     `json:"weight"`
	AdditionalWeight pgtype.Numeric     `json:"additional_weight"`
	ExerciseType     NullExerciseType   `json:"exercise_type"`
	BodyweightID     int32              `json:"bodyweight_id"`
	LogDate          pgtype.Timestamptz `json:"log_date"`
}

// Exercise log queries
func (q *Queries) LogExercise(ctx context.Context, arg LogExerciseParams) error {
	_, err := q.db.Exec(ctx, logExercise,
		arg.UserID,
		arg.ExerciseID,
		arg.Reps,
		arg.Weight,
		arg.AdditionalWeight,
		arg.ExerciseType,
		arg.BodyweightID,
		arg.LogDate,
	)
	return err
}

const updateExerciseLog = `-- name: UpdateExerciseLog :exec
UPDATE exercise_logs
SET
    reps = $3,
    weight = $4,
    additional_weight = $5,
    exercise_type = $6,
    bodyweight_id = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE
    user_id = $1 AND exercise_id = $2 AND log_date = $8
`

type UpdateExerciseLogParams struct {
	UserID           int32              `json:"user_id"`
	ExerciseID       int32              `json:"exercise_id"`
	Reps             int32              `json:"reps"`
	Weight           pgtype.Numeric     `json:"weight"`
	AdditionalWeight pgtype.Numeric     `json:"additional_weight"`
	ExerciseType     NullExerciseType   `json:"exercise_type"`
	BodyweightID     int32              `json:"bodyweight_id"`
	LogDate          pgtype.Timestamptz `json:"log_date"`
}

func (q *Queries) UpdateExerciseLog(ctx context.Context, arg UpdateExerciseLogParams) error {
	_, err := q.db.Exec(ctx, updateExerciseLog,
		arg.UserID,
		arg.ExerciseID,
		arg.Reps,
		arg.Weight,
		arg.AdditionalWeight,
		arg.ExerciseType,
		arg.BodyweightID,
		arg.LogDate,
	)
	return err
}
